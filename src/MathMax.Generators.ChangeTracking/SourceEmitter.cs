using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace MathMax.Generators.ChangeTracking;


/// <summary>
/// Handles transforming a <see cref="TrackGenerationModel"/> into C# source files. Pure emission concern.
/// </summary>
public static class SourceEmitter
{
    public static void Emit(SourceProductionContext spc, TrackGenerationModel model)
    {
        foreach (var kvp in model.TracksPerRoot)
        {
            var entityType = kvp.Key;
            var tracks = kvp.Value
                .GroupBy(t => (t.OwnerType, t.CollectionPropertyName)) // DRY: dedupe repeated TrackBy on same property
                .Select(g => g.First())
                .ToList();
            model.RootNamespaces.TryGetValue(entityType, out var ns);
            var source = GenerateSource(entityType, tracks, ns);
            spc.AddSource(entityType.Name + ".ChangeTracking.g.cs", source);
        }
    }

    // Localized former top-level generation method (emission concern only)
    private static string GenerateSource(INamedTypeSymbol entityType, List<TrackInfo> tracks, string? namespaceName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using MathMax.ChangeTracking;");
        if (!string.IsNullOrWhiteSpace(namespaceName))
        {
            sb.Append("namespace ").Append(namespaceName).AppendLine(";");
            sb.AppendLine();
        }

        var className = entityType.Name + "ChangeTrackerGenerated";
        sb.Append("public static class ").Append(className).AppendLine();
        sb.AppendLine("{");

        var involvedTypes = DiscoverInvolvedTypes(entityType, tracks);
        var orderedTypes = involvedTypes.OrderBy(t => t.Equals(entityType, SymbolEqualityComparer.Default) ? 0 : 1)
            .ThenBy(t => t.Name).ToList();

        GenerateGetDifferencesMethod(sb, entityType, tracks, isRoot: true);
        foreach (var t in orderedTypes.Where(t => !SymbolEqualityComparer.Default.Equals(t, entityType)))
        {
            GenerateGetDifferencesMethod(sb, t, tracks, isRoot: false);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateGetDifferencesMethod(StringBuilder sb, INamedTypeSymbol currentType, List<TrackInfo> allTracks, bool isRoot)
    {
        AppendMethodHeader(sb, currentType, isRoot);
        AppendNullChecks(sb);
        sb.AppendLine();
        AppendScalarPropertyDiffs(sb, currentType);
        sb.AppendLine();
        AppendComplexPropertyDiffs(sb, currentType);
        sb.AppendLine();
        AppendCollectionDiffs(sb, currentType, allTracks);
        AppendMethodFooter(sb);
    }

    private static void AppendMethodHeader(StringBuilder sb, INamedTypeSymbol currentType, bool isRoot)
    {
        var accessibility = isRoot ? "public" : "private";
        sb.Append("    ").Append(accessibility).Append(" static IEnumerable<Difference> GetDifferences(")
            .Append("this ")
            .Append(currentType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                .Append(" left, ")
            .Append(currentType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                .Append(" right, string path = nameof(")
            .Append(currentType.Name)
            .AppendLine("))")
            .AppendLine("    {");
    }

    private static void AppendNullChecks(StringBuilder sb)
    {
        sb.AppendLine("        if (left == null && right == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            yield break;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (left == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            yield return new Difference { Path = path, LeftOwner = null, RightOwner = null, LeftValue = left, RightValue = right, Kind = DifferenceKind.Addition }; ");
        sb.AppendLine("            yield break;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (right == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            yield return new Difference { Path = path, LeftOwner = null, RightOwner = null, LeftValue = left, RightValue = right, Kind = DifferenceKind.Removal }; ");
        sb.AppendLine("            yield break;");
        sb.AppendLine("        }");
    }

    private static void AppendScalarPropertyDiffs(StringBuilder sb, INamedTypeSymbol currentType)
    {
        var scalarPropNames = currentType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsIndexer && p.GetMethod is not null && p.Type.IsSimpleType())
            .Select(prop => prop.Name);
        foreach (var propName in scalarPropNames)
        {
            sb.Append("        if (left.").Append(propName).Append(" != right.").Append(propName).AppendLine(")");
            sb.Append("            yield return ChangeTrackerExtensions.CreatePropertyDifference(path, nameof(")
                .Append(currentType.Name).Append('.').Append(propName)
                .Append("), left, right, left.").Append(propName)
                .Append(", right.").Append(propName).AppendLine(");");
        }
    }

    private static void AppendComplexPropertyDiffs(StringBuilder sb, INamedTypeSymbol currentType)
    {
        var complexProps = currentType.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsIndexer && p.GetMethod is not null && p.Type.GetTypeCategory() == TypeCategory.Complex)
            .Select(p => p.Name)
            .ToList();
        foreach (var name in complexProps)
        {
            AppendComplexPropertyDiffBlock(sb, currentType, name);
        }
    }

    private static void AppendComplexPropertyDiffBlock(StringBuilder sb, INamedTypeSymbol ownerType, string propName)
    {
        sb.AppendLine();
        sb.AppendLine($"        if (left.{propName} == null && right.{propName} != null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            yield return ChangeTrackerExtensions.CreatePropertyDifference(path, nameof({ownerType.Name}.{propName}), left, right, null, right.{propName});");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        if (left.{propName} != null && right.{propName} == null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            yield return ChangeTrackerExtensions.CreatePropertyDifference(path, nameof({ownerType.Name}.{propName}), left, right, left.{propName}, null);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        if (left.{propName} != null && right.{propName} != null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            foreach (var diff in left.{propName}.GetDifferences(right.{propName}, path + \".{propName}\"))");
        sb.AppendLine("                yield return diff;");
        sb.AppendLine("        }");
    }

    private static void AppendCollectionDiffs(StringBuilder sb, INamedTypeSymbol currentType, List<TrackInfo> allTracks)
    {
        var owningTracks = allTracks.Where(t => SymbolEqualityComparer.Default.Equals(t.OwnerType, currentType));
        foreach (var track in owningTracks)
        {
            var elementType = track.ElementType;
            var propName = track.CollectionPropertyName;
            sb.AppendLine();
            sb.Append("        if (left.").Append(propName).Append(" != null || right.").Append(propName).AppendLine(" != null)");
            sb.AppendLine("        {");
            sb.Append("            var leftList = left.").Append(propName).AppendLine(" ?? System.Array.Empty<" + elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">();");
            sb.Append("            var rightList = right.").Append(propName).AppendLine(" ?? System.Array.Empty<" + elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">();");
            sb.AppendLine($"            foreach (var diff in ChangeTrackerExtensions.DiffListByIdentity(leftList, rightList, path + \".{propName}\", (l, r, pth) => l.GetDifferences(r, pth), {track.KeySelectorExpression}))");
            sb.AppendLine("            { yield return diff; }");
            sb.AppendLine("        }");
        }
    }

    private static void AppendMethodFooter(StringBuilder sb)
    {
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static HashSet<INamedTypeSymbol> DiscoverInvolvedTypes(INamedTypeSymbol root, List<TrackInfo> tracks)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default) { root };
        var queue = new Queue<INamedTypeSymbol>();
        void Enqueue(INamedTypeSymbol t)
        {
            if (set.Add(t))
            {
                queue.Enqueue(t);
            }
        }
        queue.Enqueue(root);
        foreach (var e in tracks.Select(t => t.ElementType)) Enqueue(e);
        foreach (var o in tracks.Select(t => t.OwnerType)) Enqueue(o);
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            foreach (var typeSymbol in current.GetMembers().OfType<IPropertySymbol>().Where(p => !p.IsIndexer).Select(property => property.Type))
            {
                var cat = typeSymbol.GetTypeCategory();
                if (cat == TypeCategory.Complex && typeSymbol is INamedTypeSymbol nts)
                {
                    Enqueue(nts);
                }
            }
        }
        return set;
    }
}
